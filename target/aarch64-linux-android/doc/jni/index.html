<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Safe JNI Bindings in Rust"><title>jni - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="jni" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (7f99507f5 2026-02-19)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-41dd4d93.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate jni</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../jni/index.html">jni</a><span class="version">0.21.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safe-jni-bindings-in-rust" title="Safe JNI Bindings in Rust">Safe JNI Bindings in Rust</a><ul><li><a href="#getting-started" title="Getting Started">Getting Started</a></li><li><a href="#launching-jvm-from-rust" title="Launching JVM from Rust">Launching JVM from Rust</a></li><li><a href="#see-also" title="See Also">See Also</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Crate <span>jni</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/jni/lib.rs.html#1-231">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="safe-jni-bindings-in-rust"><a class="doc-anchor" href="#safe-jni-bindings-in-rust">§</a>Safe JNI Bindings in Rust</h2>
<p>This crate provides a (mostly) safe way to implement methods in Java using
the JNI. Because who wants to <em>actually</em> write Java?</p>
<h3 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting Started</h3>
<p>Naturally, any ffi-related project is going to require some code in both
languages that we’re trying to make communicate. Java requires all native
methods to adhere to the Java Native Interface (JNI), so we first have to
define our function signature from Java, and then we can write Rust that
will adhere to it.</p>
<h4 id="the-java-side"><a class="doc-anchor" href="#the-java-side">§</a>The Java side</h4>
<p>First, you need a Java class definition. <code>HelloWorld.java</code>:</p>
<div class="example-wrap"><pre class="language-java"><code>class HelloWorld {
    // This declares that the static `hello` method will be provided
    // a native library.
    private static native String hello(String input);

    static {
        // This actually loads the shared object that we&#39;ll be creating.
        // The actual location of the .so or .dll may differ based on your
        // platform.
        System.loadLibrary(&quot;mylib&quot;);
    }

    // The rest is just regular ol&#39; Java!
    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;josh&quot;);
        System.out.println(output);
    }
}</code></pre></div>
<p>Compile this to a class file with <code>javac HelloWorld.java</code>.</p>
<p>Trying to run it now will give us the error <code>Exception in thread "main" java.lang.UnsatisfiedLinkError: no mylib in java.library.path</code> since we
haven’t written our native code yet.</p>
<p>To do that, first we need the name and type signature that our Rust function
needs to adhere to. Luckily, the Java compiler can generate that for you!
Run <code>javac -h . HelloWorld.java</code> and you’ll get a <code>HelloWorld.h</code> output to your
directory. It should look something like this:</p>
<div class="example-wrap"><pre class="language-c"><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     HelloWorld
 * Method:    hello
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_HelloWorld_hello
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif</code></pre></div>
<p>It’s a C header, but luckily for us, the types will mostly match up. Let’s
make our crate that’s going to compile to our native library.</p>
<h4 id="the-rust-side"><a class="doc-anchor" href="#the-rust-side">§</a>The Rust side</h4>
<p>Create your crate with <code>cargo new mylib</code>. This will create a directory
<code>mylib</code> that has everything needed to build an basic crate with <code>cargo</code>. We
need to make a couple of changes to <code>Cargo.toml</code> before we do anything else.</p>
<ul>
<li>Under <code>[dependencies]</code>, add <code>jni = "0.21.1"</code></li>
<li>Add a new <code>[lib]</code> section and under it, <code>crate_type = ["cdylib"]</code>.</li>
</ul>
<p>Now, if you run <code>cargo build</code> from inside the crate directory, you should
see a <code>libmylib.so</code> (if you’re on linux) or a <code>libmylib.dylib</code> (if you are on OSX) in the <code>target/debug</code>
directory.</p>
<p>The last thing we need to do is to define our exported method. Add this to
your crate’s <code>src/lib.rs</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This is the interface to the JVM that we'll call the majority of our
// methods on.
</span><span class="kw">use </span>jni::JNIEnv;

<span class="comment">// These objects are what you should use as arguments to your native
// function. They carry extra lifetime information to prevent them escaping
// this context and getting used after being GC'd.
</span><span class="kw">use </span>jni::objects::{JClass, JString};

<span class="comment">// This is just a pointer. We'll be returning it from our function. We
// can't return one of the objects with lifetime information because the
// lifetime checker won't let us.
</span><span class="kw">use </span>jni::sys::jstring;

<span class="comment">// This keeps Rust from "mangling" the name and making it unique for this
// crate.
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"system" </span><span class="kw">fn </span>Java_HelloWorld_hello&lt;<span class="lifetime">'local</span>&gt;(<span class="kw-2">mut </span>env: JNIEnv&lt;<span class="lifetime">'local</span>&gt;,
<span class="comment">// This is the class that owns our static method. It's not going to be used,
// but still must be present to match the expected signature of a static
// native method.
                                                     </span>class: JClass&lt;<span class="lifetime">'local</span>&gt;,
                                                     input: JString&lt;<span class="lifetime">'local</span>&gt;)
                                                     -&gt; jstring {
    <span class="comment">// First, we have to get the string out of Java. Check out the `strings`
    // module for more info on how this works.
    </span><span class="kw">let </span>input: String =
        env.get_string(<span class="kw-2">&amp;</span>input).expect(<span class="string">"Couldn't get java string!"</span>).into();

    <span class="comment">// Then we have to create a new Java string to return. Again, more info
    // in the `strings` module.
    </span><span class="kw">let </span>output = env.new_string(<span class="macro">format!</span>(<span class="string">"Hello, {}!"</span>, input))
        .expect(<span class="string">"Couldn't create java string!"</span>);

    <span class="comment">// Finally, extract the raw pointer to return.
    </span>output.into_raw()
}</code></pre></div>
<p>Note that the type signature for our function is almost identical to the one
from the generated header, aside from our lifetime-carrying arguments.</p>
<h4 id="final-steps"><a class="doc-anchor" href="#final-steps">§</a>Final steps</h4>
<p>That’s it! Build your crate and try to run your Java class again.</p>
<p>… Same error as before you say? Well that’s because JVM is looking for
<code>mylib</code> in all the wrong places. This will differ by platform thanks to
different linker/loader semantics, but on Linux, you can simply <code>export LD_LIBRARY_PATH=/path/to/mylib/target/debug</code>. Now, you should get the
expected output <code>Hello, josh!</code> from your Java class.</p>
<h3 id="launching-jvm-from-rust"><a class="doc-anchor" href="#launching-jvm-from-rust">§</a>Launching JVM from Rust</h3>
<p>It is possible to launch a JVM from a native process using the <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/invocation.html">Invocation API</a>, provided
by <a href="struct.JavaVM.html"><code>JavaVM</code></a>.</p>
<h3 id="see-also"><a class="doc-anchor" href="#see-also">§</a>See Also</h3><h4 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h4>
<ul>
<li><a href="https://github.com/jni-rs/jni-rs/tree/master/example">Example project</a></li>
<li>Our <a href="https://github.com/jni-rs/jni-rs/tree/master/tests">integration tests</a> and <a href="https://github.com/jni-rs/jni-rs/tree/master/benches">benchmarks</a></li>
</ul>
<h4 id="jni-documentation"><a class="doc-anchor" href="#jni-documentation">§</a>JNI Documentation</h4>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html">Java Native Interface Specification</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a> — general tips on JNI development and some Android-specific</li>
</ul>
<h4 id="open-source-users"><a class="doc-anchor" href="#open-source-users">§</a>Open-Source Users</h4>
<ul>
<li>The Servo browser engine Android <a href="https://github.com/servo/servo/tree/master/ports/libsimpleservo">port</a></li>
<li>The Exonum framework <a href="https://github.com/exonum/exonum-java-binding/tree/master/exonum-java-binding/core/rust">Java Binding</a></li>
<li>MaidSafe <a href="https://github.com/maidsafe/safe_client_libs/tree/master/safe_app_jni">Java Binding</a></li>
</ul>
<h4 id="other-projects-simplifying-java-and-rust-communication"><a class="doc-anchor" href="#other-projects-simplifying-java-and-rust-communication">§</a>Other Projects Simplifying Java and Rust Communication</h4>
<ul>
<li>Consider <a href="https://github.com/jnr/jnr-ffi/">JNR</a> if you just need to use a native library with C interface</li>
<li>Watch OpenJDK <a href="https://jdk.java.net/panama/">Project Panama</a> which aims to enable using native libraries
with no JNI code</li>
<li>Consider <a href="http://www.graalvm.org/docs/why-graal/#for-java-programs">GraalVM</a> — a recently released VM that gives zero-cost
interoperability between various languages (including Java and <a href="http://www.graalvm.org/docs/reference-manual/languages/llvm/#running-rust">Rust</a> compiled
into LLVM-bitcode)</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="descriptors/index.html" title="mod jni::descriptors">descriptors</a></dt><dd>Descriptors for classes and method IDs.</dd><dt><a class="mod" href="errors/index.html" title="mod jni::errors">errors</a></dt><dd>Errors. Do you really need more explanation?</dd><dt><a class="mod" href="objects/index.html" title="mod jni::objects">objects</a></dt><dd>Wrappers for object pointers returned from the JVM.</dd><dt><a class="mod" href="signature/index.html" title="mod jni::signature">signature</a></dt><dd>Parser for java type signatures.</dd><dt><a class="mod" href="strings/index.html" title="mod jni::strings">strings</a></dt><dd>String types for going to/from java strings.</dd><dt><a class="mod" href="sys/index.html" title="mod jni::sys">sys</a></dt><dd><code>jni-sys</code> re-exports</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AttachGuard.html" title="struct jni::AttachGuard">Attach<wbr>Guard</a></dt><dd>A RAII implementation of scoped guard which detaches the current thread
when dropped. The attached <code>JNIEnv</code> can be accessed through this guard
via its <code>Deref</code> implementation.</dd><dt><a class="struct" href="struct.Executor.html" title="struct jni::Executor">Executor</a></dt><dd>Thread attachment manager. It allows to execute closures in attached threads with automatic
local references management done with <code>with_local_frame</code>. It combines the performance benefits
of permanent attaches whilst removing the risk of local references leaks if used consistently.</dd><dt><a class="struct" href="struct.JNIEnv.html" title="struct jni::JNIEnv">JNIEnv</a></dt><dd>FFI-compatible JNIEnv struct. You can safely use this as the JNIEnv argument
to exported methods that will be called by java. This is where most of the
magic happens. All methods on this object are wrappers around JNI functions,
so the documentation on their behavior is still pretty applicable.</dd><dt><a class="struct" href="struct.JavaVM.html" title="struct jni::JavaVM">JavaVM</a></dt><dd>The Java VM, providing <a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jni/invocation.html">Invocation API</a> support.</dd><dt><a class="struct" href="struct.MonitorGuard.html" title="struct jni::MonitorGuard">Monitor<wbr>Guard</a></dt><dd>Guard for a lock on a java object. This gets returned from the <code>lock_obj</code>
method.</dd><dt><a class="struct" href="struct.NativeMethod.html" title="struct jni::NativeMethod">Native<wbr>Method</a></dt><dd>Native method descriptor.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.JNIVersion.html" title="enum jni::JNIVersion">JNIVersion</a></dt><dd>JNI Version</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.DEFAULT_LOCAL_FRAME_CAPACITY.html" title="constant jni::DEFAULT_LOCAL_FRAME_CAPACITY">DEFAULT_<wbr>LOCAL_<wbr>FRAME_<wbr>CAPACITY</a></dt><dd>The capacity of local frames, allocated for attached threads by default. Same as the default
value Hotspot uses when calling native Java methods.</dd></dl></section></div></main></body></html>